<script src="../tinytest.js"></script>
<script>

// The reduce() method executes a reducer function (that you provide) on each element of the array, resulting in a single output value.

// Parameters:
// callback; A function to execute on each element in the array (except for the first, if no initialValue is supplied).

// It takes four arguments:

// accumulator; The accumulator accumulates callback's return values. It is the accumulated value previously returned in the last invocation of the callbackâ€”or initialValue, if it was supplied (see below).
// currentValue; The current element being processed in the array.
// index [Optional]; The index of the current element being processed in the array. Starts from index 0 if an initialValue is provided. Otherwise, it starts from index 1.
// array [Optional]; The array reduce() was called upon.
// initialValue [Optional]; A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first element in the array will be used and skipped. Calling reduce() on an empty array without an initialValue will throw a TypeError.

// Prototype implementation: 
  //  function reduce(array, callback, startingValue){
  //   var resultSoFar = startingValue;
  //   for (var i = 0; i < array.length; i++) {
  //     resultSoFar = callback(resultSoFar, array[i], i, array);
  //   }
  //   return resultSoFar;
  //}

// Function signatures:  
// reduce(array, callback[, initialValue])

// Return value: 
    // The single value that results from the reduction.

function reduce(array, callback, initialValue) {
  var startingIndex = Object.keys(array)[0];
  var resultSoFar = initialValue;
  var length = array.length;
  var arrayIndexes = Object.keys(array);

  if (arguments.length < 3) {
    if (arrayIndexes.length === 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }

    if (arrayIndexes.length === 1) {
      var onlyIndex = arrayIndexes[0];
      var onlyElement = array[onlyIndex];
      return onlyElement;
    } 
    resultSoFar = array[startingIndex] 
    startingIndex++; 
  } else {
    if (arrayIndexes.length === 0) {
      return initialValue;
    }
  }

  for (var i = startingIndex; i < array.length; i++) {
    resultSoFar = callback(resultSoFar, array[i], i, array);
  }
    return resultSoFar;
}

tests({
  'If initialValue, callback should run array.length times': function() {
    var numberOfTimesCallbackHasRun = 0;
    reduce([,1], function() {
      numberOfTimesCallbackHasRun++;
    }, 0);
    eq(numberOfTimesCallbackHasRun, 1);
  },
  'If no initialValue, callback should run array.length -1 times': function() {
    var numberOfTimesCallbackHasRun = 0;
    reduce([1], function() {
      numberOfTimesCallbackHasRun++;
    });
    eq(numberOfTimesCallbackHasRun, 0);
  },
  'If initialValue, previousValue should start with initialValue.': function() {
    reduce([1], function(previousValue) {
      eq(previousValue, 0);  
    }, 0);
  },
  'If initialValue, currentValue should start with array[0].': function() {
    reduce([1], function(previousValue, currentValue) {
      eq(currentValue, 1);  
    }, 0);
  },
  'If initialValue, callback will start at index 0.': function() {
    reduce([1], function(previousValue, currentValue, currentIndex) {
      eq(currentIndex, 0);    
    }, 0);
  },

  'If no initialValue, previousValue should start with array[0].': function() {
    reduce([1, 2], function(previousValue) {
      eq(previousValue, 1);  
    });
  },
  'If no initialValue, currentValue should start with array[1].': function() {
     reduce([1, 2], function(previousValue, currentValue) {
      eq(currentValue, 2);    
    });
  },
  'If no initialValue, callback will start at index 1.': function() {
    reduce([1, 2], function(previousValue, currentValue, currentIndex) {
      eq(currentIndex, 1);    
    });
  },
  'If initialValue and array is empty, return initialValue without calling callback.': function() {
    var numberOfTimesCallbackHasRun = 0;
    var initialValue = 0;
    var reduceResult = reduce([,,], function() {
      numberOfTimesCallbackHasRun++;
    }, initialValue);
    eq(reduceResult, initialValue);
    eq(numberOfTimesCallbackHasRun, 0);
  },
  'If no initialValue and array has one element, return that element without calling callback.': function() {
    var numberOfTimesCallbackHasRun = 0;
    var reduceResult = reduce([1], function() {
        numberOfTimesCallbackHasRun++;
    });
    eq(reduceResult, 1);
    eq(numberOfTimesCallbackHasRun, 0);
  },

  'It should actually reduce.': function() {
    var sum = reduce([1, 2, 3], function(a, b){
        return a + b;
    }, 0);
    eq(sum, 6);
  },
  'If initialValue, it should exclude holes.': function() {
    reduce([,1, 2], function(previousValue, currentValue, currentIndex) {
      eq(currentIndex, 1);    
    });
  },
  'If NO initialValue, it should exclude holes too.': function() {
    var sum = reduce([, 1, , 2, 3], function(a, b){
        return a + b;
    });
    eq(sum, 6);
  },
  'If no initialValue, and array is empty, throw TypeError.': function() {
    var isTypeError = false;
    try {
      reduce([], function() {});
    } catch(e) {
      isTypeError = (e instanceof TypeError);
    }
    eq(isTypeError, true);
  },
  'It should pass array as fourth argument to callback.': function() {
    var testArray = [1, 2];
    reduce(testArray, function(previousValue, currentValue, currentIndex, arrayToReduce) {
      eq(arrayToReduce, testArray);    
    }, 0);
  }    
});
</script>